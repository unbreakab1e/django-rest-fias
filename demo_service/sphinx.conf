source default_addrobj
{
    type                = pgsql
    sql_host            = 127.0.0.1
    sql_user            = postgres
    sql_pass            = postgres
    sql_db              = fias
    sql_port            = 

    sql_query           = WITH RECURSIVE PATH (docid, aoguid, aolevel, scname, fullname, formalname, item_weight, parentguid) AS (\
  SELECT DISTINCT ON (ao.aoguid) NEXTVAL('fias_addrobj_docid_seq') AS docid, ao.aoguid, ao.aolevel,\
    sn.socrname::TEXT AS scname,\
    ao.shortname || ' ' || formalname AS fullname, ao.formalname,\
    sn.item_weight, ao.parentguid\
  FROM fias_addrobj AS ao\
    INNER JOIN fias_socrbase AS sn ON (sn.scname = ao.shortname AND sn.level = ao.aolevel)\
  WHERE aolevel = 1 AND livestatus = TRUE\
  UNION\
  SELECT DISTINCT ON (child.aoguid) NEXTVAL('fias_addrobj_docid_seq') AS docid, child.aoguid, child.aolevel,\
    PATH.scname::TEXT || ', ' || sn.socrname::TEXT AS scname,\
    PATH.fullname || ', ' || child.shortname || ' ' || child.formalname AS fullname, child.formalname,\
    sn.item_weight, child.parentguid\
  FROM fias_addrobj AS child\
    INNER JOIN fias_socrbase AS sn ON (sn.scname = child.shortname AND sn.level = child.aolevel)\
    , PATH\
  WHERE child.parentguid = PATH.aoguid AND livestatus = TRUE\
)\
SELECT * FROM PATH;

    

    sql_query_pre       = CREATE TEMPORARY SEQUENCE fias_addrobj_docid_seq;
    sql_query_post      = DROP SEQUENCE IF EXISTS fias_addrobj_docid_seq;

    sql_field_string    = fullname
    sql_attr_string     = aoguid
    sql_attr_uint       = aolevel
    sql_attr_uint       = item_weight
    sql_attr_string     = parentguid
    sql_field_string    = formalname
}

index default_addrobj
{
    docinfo             = extern
    morphology          = stem_ru
    min_stemming_len    = 2

    stopwords           =
    min_word_len        = 2
    charset_type        = utf-8
    min_prefix_len      = 1
    min_infix_len       = 0
    enable_star         = 1

    # strip html by default
    html_strip          = 1

    ignore_chars        = @, -
    charset_table = 0..9, A..Z->a..z, _, a..z, \
        U+0401->U+0435, U+0451->U+0435, \
        U+410..U+42F->U+430..U+44F, U+430..U+44F

    source              = default_addrobj
    path                = /var/lib/sphinxsearch/data/default_addrobj
}

indexer
{
        # memory limit, in bytes, kiloytes (16384K) or megabytes (256M)
        # optional, default is 32M, max is 2047M, recommended is 256M to 1024M
        mem_limit               = 256M

        # maximum IO calls per second (for I/O throttling)
        # optional, default is 0 (unlimited)
        #
        # max_iops              = 40

        # maximum IO call size, bytes (for I/O throttling)
        # optional, default is 0 (unlimited)
        #
        max_iosize              = 524288
}

searchd
{

        listen                  = 127.0.0.1:9306:mysql41

        # required by RT-indexes
        workers                 = threads

        # log file, searchd run info is logged here
        # optional, default is 'searchd.log'
        log                     = /var/log/sphinx/searchd.log

        # query log file, all search queries are logged here
        # optional, default is empty (do not log queries)
        query_log               = /var/log/sphinx/query.log

        # client read timeout, seconds
        # optional, default is 5
        read_timeout    = 5

        # maximum amount of children to fork (concurrent searches to run)
        # optional, default is 0 (unlimited)
        max_children    = 30

        # PID file, searchd process ID file name
        # mandatory
        #pid_file                = /var/run/searchd.pid
        pid_file                = /tmp/searchd.pid

        # max amount of matches the daemon ever keeps in RAM, per-index
        # WARNING, THERE'S ALSO PER-QUERY LIMIT, SEE SetLimits() API CALL
        # default is 1000 (just like Google)
        max_matches             = 1000

        # seamless rotate, prevents rotate stalls if precaching huge datasets
        # optional, default is 1
        seamless_rotate = 1

        # whether to forcibly preopen all indexes on startup
        # optional, default is 0 (do not preopen)
        preopen_indexes = 0

        # whether to unlink .old index copies on succesful rotation.
        # optional, default is 1 (do unlink)
        unlink_old              = 1


        # http://sphinxsearch.com/docs/2.0.6/conf-compat-sphinxql-magics.html
        compat_sphinxql_magics = 0
}
